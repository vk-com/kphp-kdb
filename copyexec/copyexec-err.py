#!/usr/bin/python
import sys, os

class SuperFile:
    def __init__(self, name):
        self.path = os.path.join(sys.path[0], name)
        self.lines = ['/* Generated by python script */']
    def __enter__(self):
        return self
    def __exit__(self, type, value, traceback):
        with open(self.path, 'w') as f:
            f.write('\n'.join(self.lines) + '\n')
    def append(self, line):
        self.lines.append(line)

errors = [
    'LSEEK', 'READ', 'CRC32', 'TYPE', 'DECRYPT', 'MALLOC', 'ALIGN', 'SIZE',
    'SHA1', 'MKDIR', 'OPEN', 'FSTAT'
]
errors += [
    'ST_DEV', 'ST_INO', 'READIN', 'STATUS', 'FORK', 'CHDIR', 'CREAT', 'STAT',
    'PUBKEY_PERMISSIONS'
]
errors += ['INVAL']

########### copyexec-results errors ###########
errors += [
    'VOLUME_ID_MISMATCHED', 'HOSTNAME_MISMATCHED', 'DISCONNECT', 'OLD_RESULT'
]

errors = [(s, -(i+1)) for i, s in enumerate (errors)]
errors.append (('UNKNOWN', -999))

with SuperFile('copyexec-err.h') as f:
     # not using `% tuple_ for tuple_ in errors` just for clarity
    for error_name, error_code in errors:
        f.append('#define COPYEXEC_ERR_%s (%d)' % (error_name, error_code))
    f.append('char *copyexec_strerror (int err);')

with SuperFile('copyexec-err.c') as f:
    f.append('#include <stdio.h>')
    f.append('#include <assert.h>')
    f.append('#include "copyexec-err.h"')
    f.append('char *copyexec_strerror (int err) {')
    f.append(' static char buf[64];')
    f.append(' switch (err) {')
    for error_name, error_code in errors:
        f.append(' case COPYEXEC_ERR_%s: return "COPYEXEC_ERR_%s"; break;'
                 % (error_name, error_name))
    f.append(' default: assert (snprintf (buf, sizeof (buf), "COPYEXEC_ERR_UNKNOWN (%d)", err) < sizeof (buf));')
    f.append(' return buf;')
    f.append(' }')
    f.append('}')
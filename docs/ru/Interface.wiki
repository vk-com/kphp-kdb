== Использование KittenDB/Engine ==

KittenDB/Engine состоит из большого количества независимых утилит со схожими опциями командной строки и интерфейсом.
Каждая такая утилита обычно называется "движком" и представляет из себя специализированную нереляционную БД, построенную по принципу "бинлог" + "образ в памяти" + "снимок на диске". Например, text-engine используется для хранения большого количества текстов и поиска по ним, "lists-engine" -- для хранения большого количества списков чисел, и т.д.

== Запуск движка ==

Для компиляции и запуска нужен Linux с ядром не менее 2.6.18, желательно не менее 3.0. Другие операционные системы на данный момент не поддерживаются, например, из-за явного использования системного вызова epoll().

Запускаемые файлы создаются `make` в подкаталог `objs/bin`. Нужные из них удобно скопировать в какой-нибудь общедоступный каталог, например, `/usr/share/engine/bin/` . Если используется Debian, полезно использовать init.d-файл и logrotate-файл из каталога `scripts`. Там же есть скрипт `start-engine`, который тоже полезно положить в `/usr/share/engine/bin/`.

Конфигурационные файлы хранятся в `/etc/engine`. Они называются `/etc/engine/engine.$id.conf`, где $id -- не более чем трёхсимвольный идентификатор экземпляра движка (обычно используются числа 1--99, а также латинские буквы a,b,c...).

Такой конфигурационный файл обычно содержит название движка, его основной параметр (префикс имени бинлога) и прочие опции командной строки. Например:


Файл /etc/engine/engine.1.conf:
<br>
---------
<br>
execute lists-engine
<br>
arg1    groups23
<br>
-p	11200
<br>
-vvv
<br>
---------

При запуске /etc/init.d/engine start 1 или просто /etc/init.d/engine start (который легко сделать автоматическим при загрузке)
будет запущен

/usr/share/engine/bin/lists-engine groups23 -u kitten -p 11200 -vv -l /var/log/engine/engine-1.log >> /var/log/engine/engine-1.log 2>&1

из домашнего каталога /var/lib/engine/

Этот экземпляр lists-engine будет использовать /var/lib/engine/groups23.bin в качестве бинлога (основного хранилища данных) и будет отвечать на memcache или rpc-запросы по tcp-порту 11200.

Кроме того, если его запустить под root'ом, он будет работать под пользователем kitten (которому лучше всего прописать /var/lib/engine в качестве домашнего каталога и uid 239). Желательно, чтобы у этого пользователя были права rwx на каталог /var/lib/engine, или нужные подкаталоги.

Внимание: перед запуском под Линукс желательно сделать 
<br>
echo 1 > /proc/sys/vm/overcommit_memory

либо прописать vm.overcommit_memory = 1 в /etc/sysctl.conf.

== Создание бинлога ==

Как уже отмечалось, движки используют бинлоги в качестве основного хранилища данных. Если бинлога нет, они его не создают, а аварийно завершают работу. Поэтому перед первым запуском нужно создать "пустой" бинлог, состоящий из 24 байтов (запись LEV_START). 
Для lists-engine он выглядит примерно так:

+0  int LEV_START = 0x044c644b;  // общий заголовок для всех KDB-бинлогов
<br>
+4  int type      = 0x6ef20101;  // формат бинлога (свой у каждого движка)
<br>
+8  int extra_bytes = 0;
<br>
+12 int split_mod = 128;         // модуль для дробления
<br>
+16 int split_min = 98;
<br>
+20 int split_max = 99;          // обычно 0 &lt;= split_min &lt; split_max &lt;= split_mod, и split_max = split_min + 1
<br>
+24 дополнительные байты в количестве extra_bytes штук, дополненные до границы 4 байт (в данном случае не нужны)

$ hexdump -C /var/lib/engine/groups23.bin 
<br>
00000000  4b 64 4c 04 01 01 f2 6e  00 00 00 00 80 00 00 00  |KdL....n........|
<br>
00000010  62 00 00 00 63 00 00 00                           |b...c...|

Параметры дробления означают, что этот экземпляр lists-engine будет обрабатывать запросы к спискам с list_id, удовлетворяющим
<br>
abs(list_id) % 128 == 98.

После того, как бинлог создан и передан пользователю kitten, можно запускать lists-engine -- из командной строки или через механизм запуска демонов ( /etc/init.d/engine start 1 ).

== Работа с запущенным движком ==

=== Memcache-интерфейс ===
Почти все движки поддерживают вариант memcache-интерфейса. Поэтому к ним можно подключиться из PHP или другого языка высокого уровня через обычный memcache-интерфейс:

<pre>
$MC_Lists = new Memcache ('127.0.0.1', 11200);
$MC_Lists->add ("entry98_239", "1,0");
$MC_Lists->add ("entry98_666", "2,66666");
$MC_Lists->add ("entry226_77", "7,4");
var_dump ($MC_Lists->get ("list98");
</pre>

Либо даже через telnet:

<pre>
$ telnet localhost 11200
version
VERSION/2.3.9
set entry98_17 0 0 3
3,0
STORED
get list98
3,17,239,666
</pre>

Через telnet особенно интересно вводить команду stats.

=== RPC-интерфейс ===
Это более прогрессивный метод, однако он требует установки расширения vkext для PHP (в KittenPHP поддержка RPC встроена). В конфигурации vkext надо указать путь к файлу combined.tlo, генерируемому при компиляции движков через make в каталоге objs/TL .

После этого можно будет слать запросы примерно так:
<pre>
$RPC_Lists = new_rpc_connection ("localhost", 11200);
var_dump (rpc_tl_query_result (rpc_tl_query ($RPC_Lists, array (array ("lists.setEntry", 1, 1, array (98), (1 << 15) + (1 << 6), array ("flags" => 3, "object_id" => array (17)))))));
var_dump (rpc_tl_query_result (rpc_tl_query ($RPC_Lists, array (array ("lists.getList", 1, 1, array (98), (1 << 15))))));
--
array ("_" => "rpcQueryResult", "result" => true);
array ("_" => "rpcQueryResult", "result" => array ("total" => 3, "vector" => array (array (17), array (239), array (666))));
</pre>

== MC-Proxy и RPC-Proxy ==

В каких-то случаях полезно мультиплексировать все запросы с сервера к различным кластерам движков (например, 128 экземпляров lists-engine для хранения "groups" образуют один кластер; другие 64 экземпляров lists образуют кластер "friends"; ещё 256 экземпляров text-engine образуют кластер "msg", и т.д.) через специальный софт, называемый mc-proxy (для memcache-интерфейса) или rpc-proxy (для rpc-интерфейса).

Такой прокси создаёт несколько кластеров (каждый на своём порту), и мультиплексирует поступающие (обычно через localhost) запросы на сервера, перечисленные в конфигурации кластера, в зависимости от значения параметра дробления (вроде list_id) в теле запроса. Тем самым каждому PHP-worker'у не нужно самостоятельно держать соединения ко всем используемым движкам и отслеживать, куда нужно отправлять какой запрос.

